package generator

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/Eranmonnie/testgen/internal/config"
	"github.com/Eranmonnie/testgen/pkg/models"
)

func TestNewTestGenerator(t *testing.T) {
	cfg := &config.Config{
		AI: config.AIConfig{
			Provider: "openai",
			Model:    "gpt-4",
			Timeout:  30,
		},
	}

	generator := NewTestGenerator(cfg)

	if generator == nil {
		t.Fatal("Expected generator to be created")
	}

	if generator.config != cfg {
		t.Error("Expected config to be set")
	}

	if generator.client == nil {
		t.Error("Expected HTTP client to be created")
	}
}

func TestBuildPrompt(t *testing.T) {
	cfg := &config.Config{
		AI: config.AIConfig{
			Provider: "openai",
			Model:    "gpt-4",
		},
	}

	generator := NewTestGenerator(cfg)

	// Create test request
	request := models.TestGenerationRequest{
		Functions: []models.FunctionInfo{
			{
				Name:      "ValidateUser",
				Package:   "user",
				Signature: "func ValidateUser(u *User) error",
				Parameters: []models.ParameterInfo{
					{Name: "u", Type: "*User"},
				},
				Returns: []models.ReturnInfo{
					{Type: "error"},
				},
				Comments: []string{"ValidateUser checks if a user is valid"},
				Complexity: models.ComplexityInfo{
					HasErrors:   true,
					HasPointers: true,
				},
			},
		},
		Context: models.RequestContext{
			PackageName: "user",
			ProjectName: "testproject",
			Imports:     []string{"errors", "fmt"},
			GitContext: models.GitContext{
				CommitMessage: "Add user validation",
			},
		},
	}

	prompt := generator.buildPrompt(request)

	// Check that prompt contains expected elements
	expectedElements := []string{
		"ValidateUser",
		"func ValidateUser(u *User) error",
		"Package: user",
		"Project: testproject",
		"handles errors",
		"uses pointers",
		"Add user validation",
		"Follow Go testing conventions",
		"JSON",
	}

	for _, element := range expectedElements {
		if !strings.Contains(prompt, element) {
			t.Errorf("Expected prompt to contain '%s'", element)
		}
	}

	// Check prompt structure
	if !strings.Contains(prompt, "Project Context:") {
		t.Error("Expected prompt to have project context section")
	}

	if !strings.Contains(prompt, "Functions to test:") {
		t.Error("Expected prompt to have functions section")
	}

	if !strings.Contains(prompt, "Response format (JSON):") {
		t.Error("Expected prompt to have response format section")
	}
}

func TestBuildTestFileContent(t *testing.T) {
	cfg := &config.Config{
		Output: config.OutputConfig{
			Suffix: "_test.go",
		},
	}

	generator := NewTestGenerator(cfg)

	functions := []models.FunctionInfo{
		{
			Name:    "ValidateUser",
			Package: "user",
		},
	}

	tests := []models.GeneratedTest{
		{
			Name:        "TestValidateUser_ValidUser",
			Code:        "func TestValidateUser_ValidUser(t *testing.T) {\n\t// Test implementation\n}",
			Description: "Test ValidateUser with valid user",
		},
		{
			Name:        "TestValidateUser_InvalidUser",
			Code:        "func TestValidateUser_InvalidUser(t *testing.T) {\n\t// Test implementation\n}",
			Description: "Test ValidateUser with invalid user",
		},
	}

	content, err := generator.buildTestFileContent("user.go", functions, tests)
	if err != nil {
		t.Fatalf("Failed to build test content: %v", err)
	}

	// Check package declaration
	if !strings.HasPrefix(content, "package user\n") {
		t.Error("Expected content to start with package declaration")
	}

	// Check imports
	if !strings.Contains(content, "import (\n\t\"testing\"\n") {
		t.Error("Expected testing import")
	}

	// Check test functions
	for _, test := range tests {
		if !strings.Contains(content, test.Code) {
			t.Errorf("Expected content to contain test: %s", test.Name)
		}

		if !strings.Contains(content, test.Description) {
			t.Errorf("Expected content to contain description: %s", test.Description)
		}
	}

	// Check generated comment
	if !strings.Contains(content, "Tests generated by testgen") {
		t.Error("Expected generated comment")
	}
}

func TestWriteTestFile(t *testing.T) {
	// Create temporary directory
	tmpDir := t.TempDir()

	cfg := &config.Config{
		Output: config.OutputConfig{
			Directory:      tmpDir,
			Suffix:         "_test.go",
			Overwrite:      true,
			BackupExisting: false,
		},
	}

	generator := NewTestGenerator(cfg)

	functions := []models.FunctionInfo{
		{
			Name:    "ValidateUser",
			Package: "user",
			File:    "user.go",
		},
	}

	tests := []models.GeneratedTest{
		{
			Name:        "TestValidateUser",
			Code:        "func TestValidateUser(t *testing.T) {\n\t// Test implementation\n}",
			Description: "Test ValidateUser function",
		},
	}

	err := generator.writeTestFile("user.go", functions, tests)
	if err != nil {
		t.Fatalf("Failed to write test file: %v", err)
	}

	// Check file was created
	expectedPath := filepath.Join(tmpDir, "user_test.go")
	if _, err := os.Stat(expectedPath); os.IsNotExist(err) {
		t.Errorf("Expected test file to be created: %s", expectedPath)
	}

	// Check file content
	content, err := os.ReadFile(expectedPath)
	if err != nil {
		t.Fatalf("Failed to read test file: %v", err)
	}

	contentStr := string(content)
	if !strings.Contains(contentStr, "package user") {
		t.Error("Expected package declaration")
	}

	if !strings.Contains(contentStr, "TestValidateUser") {
		t.Error("Expected test function")
	}
}

func TestWriteTestFileWithBackup(t *testing.T) {
	// Create temporary directory
	tmpDir := t.TempDir()

	cfg := &config.Config{
		Output: config.OutputConfig{
			Directory:      tmpDir,
			Suffix:         "_test.go",
			Overwrite:      true,
			BackupExisting: true,
		},
	}

	generator := NewTestGenerator(cfg)

	// Create existing test file
	testFilePath := filepath.Join(tmpDir, "user_test.go")
	existingContent := "package user\n\nfunc TestExisting(t *testing.T) {}\n"
	err := os.WriteFile(testFilePath, []byte(existingContent), 0644)
	if err != nil {
		t.Fatalf("Failed to create existing file: %v", err)
	}

	functions := []models.FunctionInfo{
		{
			Name:    "ValidateUser",
			Package: "user",
			File:    "user.go",
		},
	}

	tests := []models.GeneratedTest{
		{
			Name: "TestValidateUser",
			Code: "func TestValidateUser(t *testing.T) {\n\t// New test\n}",
		},
	}

	err = generator.writeTestFile("user.go", functions, tests)
	if err != nil {
		t.Fatalf("Failed to write test file: %v", err)
	}

	// Check backup was created
	backupPath := testFilePath + ".backup"
	if _, err := os.Stat(backupPath); os.IsNotExist(err) {
		t.Error("Expected backup file to be created")
	}

	// Check backup content
	backupContent, err := os.ReadFile(backupPath)
	if err != nil {
		t.Fatalf("Failed to read backup file: %v", err)
	}

	if string(backupContent) != existingContent {
		t.Error("Backup content doesn't match original file")
	}

	// Check new content was written
	newContent, err := os.ReadFile(testFilePath)
	if err != nil {
		t.Fatalf("Failed to read new test file: %v", err)
	}

	if !strings.Contains(string(newContent), "TestValidateUser") {
		t.Error("New test content not found")
	}
}

func TestWriteTestFileNoOverwrite(t *testing.T) {
	// Create temporary directory
	tmpDir := t.TempDir()

	cfg := &config.Config{
		Output: config.OutputConfig{
			Directory: tmpDir,
			Suffix:    "_test.go",
			Overwrite: false, // Don't overwrite
		},
	}

	generator := NewTestGenerator(cfg)

	// Create existing test file
	testFilePath := filepath.Join(tmpDir, "user_test.go")
	existingContent := "package user\n\nfunc TestExisting(t *testing.T) {}\n"
	err := os.WriteFile(testFilePath, []byte(existingContent), 0644)
	if err != nil {
		t.Fatalf("Failed to create existing file: %v", err)
	}

	functions := []models.FunctionInfo{
		{
			Name:    "ValidateUser",
			Package: "user",
			File:    "user.go",
		},
	}

	tests := []models.GeneratedTest{
		{
			Name: "TestValidateUser",
			Code: "func TestValidateUser(t *testing.T) {}",
		},
	}

	// Attempt to write should fail
	err = generator.writeTestFile("user.go", functions, tests)
	if err == nil {
		t.Error("Expected error when overwrite is false and file exists")
	}

	if !strings.Contains(err.Error(), "already exists") {
		t.Errorf("Expected 'already exists' error, got: %v", err)
	}
}

func TestWriteTestFiles(t *testing.T) {
	// Create temporary directory
	tmpDir := t.TempDir()

	cfg := &config.Config{
		Output: config.OutputConfig{
			Directory: tmpDir,
			Suffix:    "_test.go",
			Overwrite: true,
		},
	}

	generator := NewTestGenerator(cfg)

	// Multiple functions from different files
	functions := []models.FunctionInfo{
		{
			Name:    "ValidateUser",
			Package: "user",
			File:    "user.go",
		},
		{
			Name:    "CreateUser",
			Package: "user",
			File:    "user.go",
		},
		{
			Name:    "HandleRequest",
			Package: "handler",
			File:    "handler.go",
		},
	}

	tests := []models.GeneratedTest{
		{
			Name: "TestValidateUser",
			Code: "func TestValidateUser(t *testing.T) {}",
		},
		{
			Name: "TestCreateUser",
			Code: "func TestCreateUser(t *testing.T) {}",
		},
		{
			Name: "TestHandleRequest",
			Code: "func TestHandleRequest(t *testing.T) {}",
		},
	}

	err := generator.WriteTestFiles(functions, tests)
	if err != nil {
		t.Fatalf("Failed to write test files: %v", err)
	}

	// Check both test files were created
	userTestPath := filepath.Join(tmpDir, "user_test.go")
	handlerTestPath := filepath.Join(tmpDir, "handler_test.go")

	if _, err := os.Stat(userTestPath); os.IsNotExist(err) {
		t.Error("Expected user_test.go to be created")
	}

	if _, err := os.Stat(handlerTestPath); os.IsNotExist(err) {
		t.Error("Expected handler_test.go to be created")
	}

	// Check user test file contains both tests
	userContent, err := os.ReadFile(userTestPath)
	if err != nil {
		t.Fatalf("Failed to read user test file: %v", err)
	}

	userContentStr := string(userContent)
	if !strings.Contains(userContentStr, "TestValidateUser") {
		t.Error("User test file missing TestValidateUser")
	}

	if !strings.Contains(userContentStr, "TestCreateUser") {
		t.Error("User test file missing TestCreateUser")
	}

	// Check handler test file
	handlerContent, err := os.ReadFile(handlerTestPath)
	if err != nil {
		t.Fatalf("Failed to read handler test file: %v", err)
	}

	if !strings.Contains(string(handlerContent), "TestHandleRequest") {
		t.Error("Handler test file missing TestHandleRequest")
	}
}

func TestParseAPIResponseErrors(t *testing.T) {
	cfg := &config.Config{
		AI: config.AIConfig{Provider: "openai"},
	}

	generator := NewTestGenerator(cfg)

	// Test invalid JSON
	_, err := generator.parseAPIResponse([]byte("invalid json"), "https://api.openai.com/v1/chat/completions")
	if err == nil {
		t.Error("Expected error for invalid JSON")
	}

	// Test unknown API
	_, err = generator.parseAPIResponse([]byte("{}"), "https://unknown-api.com/")
	if err == nil {
		t.Error("Expected error for unknown API")
	}

	if !strings.Contains(err.Error(), "unknown API response format") {
		t.Errorf("Expected unknown API error, got: %v", err)
	}
}

func TestUnsupportedProvider(t *testing.T) {
	cfg := &config.Config{
		AI: config.AIConfig{
			Provider: "unsupported",
		},
	}

	generator := NewTestGenerator(cfg)

	request := models.TestGenerationRequest{
		Functions: []models.FunctionInfo{
			{Name: "Test"},
		},
	}

	_, err := generator.GenerateTests(request)
	if err == nil {
		t.Error("Expected error for unsupported provider")
	}

	if !strings.Contains(err.Error(), "unsupported AI provider") {
		t.Errorf("Expected unsupported provider error, got: %v", err)
	}
}

func TestMissingAPIKey(t *testing.T) {
	tests := []struct {
		provider string
	}{
		{"openai"},
		{"anthropic"},
	}

	for _, tt := range tests {
		t.Run(tt.provider, func(t *testing.T) {
			cfg := &config.Config{
				AI: config.AIConfig{
					Provider: tt.provider,
					APIKey:   "", // Missing API key
				},
			}

			generator := NewTestGenerator(cfg)

			request := models.TestGenerationRequest{
				Functions: []models.FunctionInfo{
					{Name: "Test"},
				},
			}

			_, err := generator.GenerateTests(request)
			if err == nil {
				t.Errorf("Expected error for missing %s API key", tt.provider)
			}

			if !strings.Contains(err.Error(), "API key not configured") {
				t.Errorf("Expected API key error, got: %v", err)
			}
		})
	}
}

func TestBuildPromptWithComplexFunction(t *testing.T) {
	cfg := &config.Config{
		AI: config.AIConfig{Provider: "openai"},
	}

	generator := NewTestGenerator(cfg)

	// Create complex function
	request := models.TestGenerationRequest{
		Functions: []models.FunctionInfo{
			{
				Name:      "ProcessData",
				Package:   "processor",
				Signature: "func (p *Processor) ProcessData(data []byte, callback func(error)) (chan Result, error)",
				IsMethod:  true,
				Receiver: &models.ReceiverInfo{
					Name: "p",
					Type: "*Processor",
				},
				Parameters: []models.ParameterInfo{
					{Name: "data", Type: "[]byte"},
					{Name: "callback", Type: "func(error)"},
				},
				Returns: []models.ReturnInfo{
					{Type: "chan Result"},
					{Type: "error"},
				},
				Comments: []string{"ProcessData processes data asynchronously"},
				Complexity: models.ComplexityInfo{
					HasErrors:     true,
					HasPointers:   true,
					HasChannels:   true,
					HasGoroutines: true,
				},
			},
		},
		Context: models.RequestContext{
			PackageName: "processor",
			ProjectName: "dataprocessor",
		},
	}

	prompt := generator.buildPrompt(request)

	// Check all complexity indicators are mentioned
	complexityIndicators := []string{
		"handles errors",
		"uses pointers",
		"uses channels",
		"uses goroutines",
	}

	for _, indicator := range complexityIndicators {
		if !strings.Contains(prompt, indicator) {
			t.Errorf("Expected prompt to contain complexity indicator: %s", indicator)
		}
	}

	// Check method receiver is mentioned
	if !strings.Contains(prompt, "Method receiver: p *Processor") {
		t.Error("Expected method receiver information")
	}

	// Check function signature
	if !strings.Contains(prompt, "func (p *Processor) ProcessData") {
		t.Error("Expected method signature")
	}
}
